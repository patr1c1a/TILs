# January 2025

## 02

### Fluent interface pattern for call chaining

_Tags: #Patterns_

I recently implemented the fluent interface design pattern in quite a simple case to improve readability:

There was this class with some methods with no return value:

```csharp
internal class Class_A
{
    internal void Method1(string parameter)
    {
        _someObject.DoSomething(parameter);
    }

    internal void Method2(int parameter1, string parameter2)
    {
        parameter1.Execute();
        parameter2.DoSomethingElse();
    }
}
```

And that class was used by several other classes where these methods had to be called multiple times:

```csharp
internal class Class_B
{
    private Class_A _classA;

    internal void Method3()
    {
        _classA.Method1("some parameter");
        _classA.Method1("some other parameter");
        _classA.Method2(123, "another parameter");
        _classA.Method1("and one more");
    }
}
```

The calls to methods from Class_A were really a lot and they were one after the other. For context, this was a Selenium project where Class_A had methods to interact with the browser elements and Class_B was the one guiding that interaction, so methods from Class_A had to be called multiple times, one after the other.

The way the fluent interface pattern was implemented here was to make methods from Class_A return an object of the very same type:

```csharp
internal class Class_A
{
    internal Class_A Method1(string parameter)
    {
        _someObject.DoSomething(parameter);
        return this;
    }

    internal Class_A Method2(int parameter1, string parameter2)
    {
        parameter1.Execute();
        parameter2.DoSomethingElse();
        return this;
    }
}
```

This made Class_B more readable by allowing to chain method calls:

```csharp
internal class Class_B
{
    private Class_A _classA;

    internal void Method3()
    {
        _classA.Method1("some parameter");
            .Method1("some other parameter");
            .Method2(123, "another parameter");
            .Method1("and one more");
    }
}
```

## 14

### Early return pattern

_Tags: #Patterns #Conditional_

I always try to keep my nesting at a minimum, but sometimes I find legacy code that has been there for ages and nobody even knows who wrote it centuries ago, which could use a refactor. This was one of the cases and there was some complex logic like this:

```csharp
public void SomeMethodIFound()
{
    if (x != y && x != z)
    {
        // more code

        if (something)
        {
            try
            {
                // more code

                foreach (item in list)
                {
                    // more code
                }

            // more code
            }
            catch (Exception ex)
            {
                // handle exception
            }
        }
        else
        {
            try
            {
                // more code

                if (something)
                {
                    // more code
                }
                else
                {
                    // more code
                }

                // more code
            }
            catch (Exception ex)
            {
                // handle exception
            }
        }
    }
    else
    {
        Logs.Add("some important information");
    }
}
```

This was a very long method with lots of code and lots of nesting and complex logic. But I was able to reduce at least one nesting level by just inverting the if condition in the first line. So, instead of `if (x != y && x != z)` I changed it to `if (x != y || x != z)` (replaces AND with OR), and added the body in the `else` block there, followed by a `return` statement (since that was the last line in the method):

```csharp
public void SomeMethodIFound()
{
    if (x == y || x == z)  // Condition is inverted
    {
        Logs.Add("some important information");  // This was the body in the 'else' block.
        return;  // I added this for an early return.
    }

    // And now, the rest of the code that was originally in the 'if' block, reducing one indentation level.

    // more code

    if (something)
    {
        try
        {
            // more code

            foreach (item in list)
            {
                // more code
            }

        // more code
        }
        catch (Exception ex)
        {
            // handle exception
        }
    }
    else
    {
        try
        {
            // more code

            if (something)
            {
                // more code
            }
            else
            {
                // more code
            }

            // more code
        }
        catch (Exception ex)
        {
            // handle exception
        }
    }
}
```
