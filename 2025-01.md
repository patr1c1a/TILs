# January 2025

## 02

### Fluent interface pattern for call chaining

_Tags: #Patterns_

I recently implemented the fluent interface design pattern in quite a simple case to improve readability:

There was this class with some methods with no return value:

```csharp
internal class Class_A
{
    internal void Method1(string parameter)
    {
        _someObject.DoSomething(parameter);
    }

    internal void Method2(int parameter1, string parameter2)
    {
        parameter1.Execute();
        parameter2.DoSomethingElse();
    }
}
```

And that class was used by several other classes where these methods had to be called multiple times:

```csharp
internal class Class_B
{
    private Class_A _classA;

    internal void Method3()
    {
        _classA.Method1("some parameter");
        _classA.Method1("some other parameter");
        _classA.Method2(123, "another parameter");
        _classA.Method1("and one more");
    }
}
```

The calls to methods from Class_A were really a lot and they were one after the other. For context, this was a Selenium project where Class_A had methods to interact with the browser elements and Class_B was the one guiding that interaction, so methods from Class_A had to be called multiple times, one after the other.

The way the fluent interface pattern was implemented here was to make methods from Class_A return an object of the very same type:

```csharp
internal class Class_A
{
    internal Class_A Method1(string parameter)
    {
        _someObject.DoSomething(parameter);
        return this;
    }

    internal Class_A Method2(int parameter1, string parameter2)
    {
        parameter1.Execute();
        parameter2.DoSomethingElse();
        return this;
    }
}
```

This made Class_B more readable by allowing to chain method calls:

```csharp
internal class Class_B
{
    private Class_A _classA;

    internal void Method3()
    {
        _classA.Method1("some parameter");
            .Method1("some other parameter");
            .Method2(123, "another parameter");
            .Method1("and one more");
    }
}
```

## 10

### Nullable value types

_Tags: #Nullables_

C# has "value types" and "reference types".

Reference types are those made by classes and they're inherently nullable, since objects are references in nature and they can reference a null value. However, primitive types like int, double or bool can't hold a null value per se. The same thing happens to structs like DateTime, TimeSpan or Guid.

To allow a value type variable to hold the null value, a `?` is added in its declaration:

```csharp
DateTime? date = getFromDatabase(purchaseDate);
```

## 14

### Early return pattern

_Tags: #Patterns #Conditionals_

I always try to keep my nesting at a minimum, but sometimes I find legacy code that has been there for ages and nobody even knows who wrote it centuries ago, which could use a refactor. This was one of those cases and there was some complex logic like this:

```csharp
public void SomeMethodIFound()
{
    if (x != y && x != z)
    {
        // more code

        if (something)
        {
            try
            {
                // more code

                foreach (item in list)
                {
                    // more code
                }

            // more code
            }
            catch (Exception ex)
            {
                // handle exception
            }
        }
        else
        {
            try
            {
                // more code

                if (something)
                {
                    // more code
                }
                else
                {
                    // more code
                }

                // more code
            }
            catch (Exception ex)
            {
                // handle exception
            }
        }
    }
    else
    {
        Logs.Add("some important information");
    }
}
```

This was a very long method with lots of code and lots of nesting and complex logic. But I was able to reduce at least one nesting level by just inverting the if condition in the first line. So, instead of `if (x != y && x != z)` I changed it to `if (x == y || x == z)`, and added the body in the `else` block there, followed by a `return` statement (since that was the last line in the method):

```csharp
public void SomeMethodIFound()
{
    if (x == y || x == z)  // Condition is inverted
    {
        Logs.Add("some important information");  // This was the body in the 'else' block.
        return;  // I added this for an early return.
    }

    // And now, the rest of the code that was originally in the 'if' block, reducing one indentation level.

    // more code

    if (something)
    {
        try
        {
            // more code

            foreach (item in list)
            {
                // more code
            }

        // more code
        }
        catch (Exception ex)
        {
            // handle exception
        }
    }
    else
    {
        try
        {
            // more code

            if (something)
            {
                // more code
            }
            else
            {
                // more code
            }

            // more code
        }
        catch (Exception ex)
        {
            // handle exception
        }
    }
}
```

## 30

### Request validation in ASP.NET

_Tags: #ASP.NET #Validations_

[Request validation in ASP.NET](https://learn.microsoft.com/en-us/aspnet/whitepapers/request-validation) prevents unencoded html from begin processed by the server. It means that validations will be executed before whatever controller is being called from the frontend.

### Escaping characters in the frontend vs the backend

_Tags: #Validations_

Related to the previous entry, escaping characters in the frontend vs the backend (or in addition to the backend) probably is a good practise for whatever technology we're using. Example:

```javascript
function search(query)
    $.ajax({
    url: '@Url.Action("Search", "Home")',
        type: "POST",
        data: { text: encodeURIComponent(query) },
    //more code
    });
```

And then, in your `Search(text)` method from the `Home` controller you'll need to decode the text before using it:

```csharp
string decodedText = HttpUtility.HtmlDecode(text);
```
